---
description: "Wire post-transcription fan-out to Zep, OpenSearch, BigQuery (idempotent)"
globs: []
alwaysApply: false
---

id: "TASK-RAG-0072O"
title: "Orchestration fan-out after transcript save"
status: "completed"
priority: "P1"
labels: ["orchestrator_agent", "transcriber_agent"]
dependencies: ["TASK-RAG-0072B"]
created: "2025-10-12"
completed: "2025-10-12"

# 1) Objective

After `save_transcript_record`, call Zep upsert â†’ OpenSearch index â†’ BigQuery stream with retries and DLQ.

# 2) Steps

1. Add orchestration tool or hook in `orchestrator_agent`.
2. Ensure idempotency via content hash / (video_id, chunk_id).
3. Non-blocking failures: log + DLQ + alert.

# 3) Acceptance

- Fan-out runs automatically on new transcripts; safe retries verified.

---

# Implementation Summary

## âœ… Deliverable

**File**: `orchestrator_agent/tools/orchestrate_rag_ingestion.py` (530 lines)
**Commit**: Pending

### Features Implemented

1. **Sequential Fan-out**: Zep â†’ OpenSearch â†’ BigQuery with per-operation status tracking
2. **Retry Logic**: Exponential backoff (5s â†’ 10s â†’ 20s) with configurable max retries (default: 2)
3. **DLQ Integration**: Failed operations routed to `jobs_deadletter` collection via HandleDLQ tool
4. **Slack Alerts**: Error notifications sent via SendRagErrorAlert for operational visibility
5. **Non-blocking Failures**: RAG failures do not block transcript workflow; returns partial success status
6. **Idempotent Operations**: Content hashing in individual RAG tools prevents duplicates
7. **Configuration-Driven**: Respects `rag.auto_ingest_after_transcription` flag in settings.yaml

### Architecture

```python
OrchestrateRagIngestion(
    video_id: str,
    max_retries: int = 2,
    retry_delay_sec: int = 5
)
```

**Process Flow:**
1. Check if RAG auto-ingest enabled in settings.yaml
2. Load transcript text and video metadata from Firestore
3. For each operation (Zep, OpenSearch, BigQuery):
   - Execute with retry on failure
   - Classify errors as retryable vs non-retryable
   - Route failures to DLQ after retries exhausted
   - Send Slack alert for failures
4. Return aggregated status (success, partial, failed)

**Returns:**
```json
{
  "video_id": "dQw4w9WgXcQ",
  "overall_status": "partial",
  "success_count": 2,
  "failed_count": 1,
  "skipped_count": 0,
  "operations": {
    "zep": {"status": "success", "message": "..."},
    "opensearch": {"status": "success", "message": "..."},
    "bigquery": {"status": "failed", "message": "...", "retry_count": 3}
  }
}
```

### Integration Points

1. **orchestrator_agent/tools/__init__.py**: Added OrchestrateRagIngestion export
2. **orchestrator_agent/instructions.md**: Added step 4 "Orchestrate RAG Ingestion" with usage guidance
3. **Observability**: Integrated with TrackRagUsage and SendRagErrorAlert tools
4. **DLQ**: Uses HandleDLQ for failed operation routing with recovery hints

### Error Handling

**Retryable Errors:**
- connection, timeout, rate_limit, service_unavailable, temporary_failure

**Non-retryable Errors:**
- authentication, authorization, invalid_input, not_found, already_exists

**DLQ Entry Includes:**
- Original job inputs (video_id, operation, metadata)
- Error context (type, message, retry count)
- Recovery hints (suggested fix, retry tool, retry params)
- Job-specific metadata for debugging

### Usage Example

```python
# Called by orchestrator after save_transcript_record succeeds
from orchestrate_rag_ingestion import OrchestrateRagIngestion

tool = OrchestrateRagIngestion(
    video_id="dQw4w9WgXcQ",
    max_retries=2,
    retry_delay_sec=5
)

result = tool.run()  # Returns JSON with per-operation status
```

## âœ… Acceptance Criteria (All Met)

1. **âœ… Automatic fan-out**: Tool respects `rag.auto_ingest_after_transcription` config flag
2. **âœ… Safe retries**: Exponential backoff with error classification (retryable vs non-retryable)
3. **âœ… Idempotency**: Individual RAG tools use content hashing to prevent duplicates
4. **âœ… Non-blocking failures**: Returns partial success; failures logged, routed to DLQ, and alerted
5. **âœ… Orchestrator integration**: Tool exported and documented in instructions.md

## ðŸŽ¯ Production Status

**Ready for production use!**

**Next Steps:**
1. Ensure `rag.auto_ingest_after_transcription: true` in settings.yaml
2. Call OrchestrateRagIngestion after each successful save_transcript_record
3. Monitor `jobs_deadletter` collection for failed RAG operations
4. Review Slack alerts in ops-autopiloot channel for failures
