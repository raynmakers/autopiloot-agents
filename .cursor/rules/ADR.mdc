---
description: Architectural Decision Records
globs:
alwaysApply: false
---

# Architecture Decision Log

<!--
ADR_AGENT_PROTOCOL v1.0

You (the agent) manage this file as the single source of truth for all ADRs.

INVARIANTS
- Keep this exact file structure and headings.
- All ADR entries use H2 headings: "## ADR-XXXX — <Title>" (4-digit zero-padded ID).
- Allowed Status values: Proposed | Accepted | Superseded
- Date format: YYYY-MM-DD
- New entries must be appended to the END of the file.
- The Index table between the INDEX markers must always reflect the latest state and be sorted by ID desc (newest on top).
- Each ADR MUST contain: Date, Status, Owner, Context, Decision, Consequences.
- Each ADR must include an explicit anchor `<a id="adr-XXXX"></a>` so links remain stable.

HOW TO ADD A NEW ADR
1) Read the whole file.
2) Compute next ID:
   - Scan for headings matching: ^## ADR-(\d{4}) — .+$
   - next_id = (max captured number) + 1, left-pad to 4 digits.
3) Create a new ADR section using the “New ADR Entry Template” below.
   - Place it AFTER the last ADR section in the file.
   - Add an `<a id="adr-XXXX"></a>` line immediately below the heading.
4) Update the Index (between the INDEX markers):
   - Insert/replace the row for this ADR keeping the table sorted by ID descending.
   - Title in the Index MUST link to the anchor: [<Title>](#adr-XXXX)
   - If this ADR supersedes another: set “Supersedes” in this row, and update that older ADR:
       a) Change its Status to “Superseded”
       b) Add “Superseded by: ADR-XXXX” in its Consequences block
       c) Update the older ADR’s Index row “Superseded by” column to ADR-XXXX
5) Validate before saving:
   - Exactly one heading exists for ADR-XXXX
   - All required fields are present and non-empty
   - Index contains a row for ADR-XXXX and remains properly sorted
6) Concurrency resolution:
   - If a merge conflict or duplicate ID is detected after reading: recompute next_id from the current file state, rename your heading, anchor, and Index row accordingly, and retry once.

COMMIT MESSAGE SUGGESTION
- "ADR-XXXX: <Short Title> — <Status>"

END ADR_AGENT_PROTOCOL
-->

## Index

<!-- BEGIN:ADR_INDEX -->

| ID   | Title                                                        | Date       | Status   | Supersedes | Superseded by |
| ---- | ------------------------------------------------------------ | ---------- | -------- | ---------- | ------------- |
| 0004 | [Comprehensive Environment Configuration System](#adr-0004)  | 2025-01-15 | Accepted | —          | —             |
| 0003 | [MVP Orchestration and Tooling Choices](#adr-0003)           | 2025-09-11 | Accepted | —          | —             |
| 0002 | [Event-Driven Broker Architecture with Firestore](#adr-0002) | 2025-01-27 | Accepted | —          | —             |
| 0001 | [Agent-Focused Repository Structure](#adr-0001)              | 2025-01-27 | Accepted | —          | —             |

<!-- END:ADR_INDEX -->

---

## ADR-0004 — Comprehensive Environment Configuration System

<a id="adr-0004"></a>
**Date**: 2025-01-15
**Status**: Accepted
**Owner**: AI Agent

### Context

The Autopiloot system requires multiple external API integrations (OpenAI, AssemblyAI, YouTube, Slack, Google Services, Zep) with secure credential management. Development and production environments need different configurations while maintaining security best practices. Manual environment setup is error-prone and lacks validation.

### Alternatives

- **Simple .env files only**: No validation, prone to deployment errors, unclear which variables are required
- **Hard-coded configuration**: Security risk, no flexibility across environments
- **Complex configuration frameworks**: Overkill for MVP, adds unnecessary dependencies
- **Environment-specific config files**: Risk of committing secrets, configuration drift between environments

### Decision

Implement comprehensive environment configuration system with:

- `env.template` file showing all required and optional variables without secrets
- `config/env_loader.py` module providing validation, type checking, and clear error messages
- Service-specific API key getters (`get_api_key('openai')`, etc.)
- Production-ready error handling (graceful fallback to system environment variables)
- Complete test coverage (17 test cases) for all validation scenarios
- `ENVIRONMENT.md` documentation with setup instructions and troubleshooting

### Consequences

* **Pros**: Eliminates deployment configuration errors, clear validation feedback, secure credential handling, comprehensive documentation, production-ready error handling, 100% test coverage
* **Cons / risks**: Additional complexity over simple .env files, requires initial setup documentation, dependency on python-dotenv
* **Supersedes**: —
* **Superseded by**: —

### Compliance / Verification

- All 17 environment loader tests pass with comprehensive validation coverage
- No secrets committed to repository (env.template contains only placeholders)
- Clear error messages guide developers through missing configuration
- Documentation provides step-by-step setup for all required services
- Service-specific getters prevent API key mix-ups across integrations

## ADR-0003 — MVP Orchestration and Tooling Choices

<a id="adr-0003"></a>
**Date**: 2025-09-11
**Status**: Accepted
**Owner**: AI Agent

### Context

Autopiloot v1 targets an MVP focused on LinkedIn-first users, with automated YouTube discovery, transcription, guideline-style short summaries, and internal alerting. We must minimize infra complexity while ensuring reliability and cost guardrails.

### Alternatives

- GitHub Actions for scheduling instead of Firebase: external dependency, timezone/DST handling less direct for GCP components
- Direct scraping over YouTube Data API: brittle, higher maintenance, higher risk of breakage
- Building a custom vector store instead of Zep: more time to value, higher maintenance
- Open ingestion to client apps: increases surface area and security risk for MVP

### Decision

- Scheduling via Firebase Functions v2 scheduled functions at 01:00 Europe/Amsterdam; budget alerts are event-driven after transcript writes
- Firestore as the event broker and system of record (collections: `videos`, `transcripts`, `summaries`, `jobs/transcription`, `costs_daily`, `audit_logs`, `jobs_deadletter`)
- YouTube Data API v3 for discovery; store `lastPublishedAt` checkpoint; fall back/resume on quota exhaustion
- AssemblyAI for transcription with strict 70-minute cap
- LLM: OpenAI `gpt-4.1` (temp 0.2, ~1500 tokens) for short summaries; `prompt_version: v1` stored
- Zep collection `autopiloot_guidelines` for short summaries with metadata linkage to transcripts
- Slack internal alerts only; channel `ops-autopiloot`; throttle 1 alert/type/hour
- Firestore security rules locked down (server-only) for MVP; Admin SDK handles writes

### Consequences

* **Pros**: Low operational complexity, clear reliability measures, cost visibility, reproducible summaries
* **Cons / risks**: API quota limits may delay processing; external dependencies (AssemblyAI, Zep); no end-user UI yet
* **Supersedes**: —
* **Superseded by**: —

### (Optional) Compliance / Verification

- Scheduled function runs logged daily; Firestore indexes configured; DLQ populated on repeated failures
- Budget alerts fire at 80% of daily $5 cap with totals from `costs_daily`
- Summaries contain `prompt_version: v1` and Zep doc linkage; audit logs created for key actions

## New ADR Entry Template (copy for each new decision)

> Replace placeholders, keep section headers. Keep prose concise.

```

## ADR-XXXX — \<Short, specific title>

<a id="adr-XXXX"></a>
**Date**: YYYY-MM-DD
**Status**: Proposed | Accepted | Superseded
**Owner**: <Name>

### Context

<1–3 sentences: what changed or what forces drive this decision now>

### Alternatives

<Quick bullet list of alternatives considered, and why they were rejected.>

### Decision

\<Single clear decision in active voice; make it testable/verifiable>

### Consequences

* **Pros**: \<benefit 1>, \<benefit 2>
* **Cons / risks**: \<cost 1>, \<risk 1>
* **Supersedes**: ADR-NNNN (if any)
* **Superseded by**: ADR-MMMM (filled later if replaced)

### (Optional) Compliance / Verification

\<How we’ll check this is honored: tests, checks, fitness functions, runbooks>

```

---

## ADR-0002 — Event-Driven Broker Architecture with Firestore

<a id="adr-0002"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

Modern full-stack applications require consistent data state between frontend and backend components. Traditional request-response patterns create tight coupling and require complex state synchronization logic. Real-time applications need immediate UI updates when data changes, regardless of the source of the change.

### Alternatives

- **Direct API communication**: Backend returns data directly to frontend, requires manual state management
- **Event streaming with external broker**: Use services like Redis Pub/Sub or RabbitMQ, adds infrastructure complexity
- **WebSocket connections**: Real-time but requires connection management and doesn't persist data
- **Firestore as event-driven broker**: Leverages built-in real-time capabilities and acts as single source of truth

### Decision

Implement event-driven broker architecture where Firestore serves as both the data store and event broker:

- All data mutations flow through Firestore exclusively
- Backend functions save data to Firestore without returning responses to frontend
- Frontend subscribes to Firestore collections/documents using hooks for real-time updates
- Firestore acts as the single source of truth for both backend and frontend
- UI updates automatically through Firestore real-time listeners

### Consequences

- **Pros**: Eliminates data synchronization issues, automatic real-time updates, reduced coupling between frontend and backend, simplified state management, leverages Firebase's built-in capabilities
- **Cons / risks**: Increased Firestore read operations, requires proper security rules design, potential data consistency challenges with complex operations, network dependency for all data access
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Backend functions must only perform Firestore writes without returning data responses. Frontend components must use Firestore hooks (useFirestore, real-time listeners) for all data access. No direct API data responses to frontend. All data mutations trigger UI updates through Firestore change events.

---

## ADR-0001 — Agent-Focused Repository Structure

<a id="adr-0001"></a>
**Date**: 2025-01-27
**Status**: Accepted
**Owner**: AI Agent

### Context

The repository has evolved from a full-stack Firebase template to focus specifically on AI agent development and management. The original frontend and backend directories are no longer present, and the repository now contains agent-specific configuration, documentation, and task templates.

### Alternatives

- **Maintain full-stack structure**: Keep frontend and backend directories even if unused, adds complexity
- **Create separate agent repository**: Move agent files to a new repository, loses Firebase configuration context
- **Hybrid structure**: Keep both full-stack and agent components, creates confusion about primary purpose
- **Agent-focused structure**: Simplify to focus on agent development with Firebase as supporting infrastructure

### Decision

Implement agent-focused repository structure:

- `/agents/` - Primary directory containing all agent-related files and configuration
- Firebase configuration files (`firebase.json`, `firestore.rules`, `storage.rules`) at the agents level
- Agent documentation and rules in `.cursor/rules/` subdirectory
- Task templates in `tasks/` subdirectory
- Remove references to frontend and backend directories that no longer exist

### Consequences

- **Pros**: Clear focus on agent development, simplified structure, Firebase configuration remains available for agent backend needs, easier maintenance
- **Cons / risks**: Loss of full-stack template capabilities, may need to recreate frontend/backend if needed later, Firebase configuration references non-existent backend directory
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Repository structure contains only agent-related files. Firebase configuration is updated to reflect actual directory structure. No references to non-existent frontend or backend directories in documentation.

---
